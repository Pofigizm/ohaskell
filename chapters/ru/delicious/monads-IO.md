----
title: Монады: на примере IO
prevChapter: /ru/delicious/monads-essence.html
nextChapter: /ru/delicious/monads-practice.html
----

Раз уж монады `IO` самые распространённые, и ни одно приложение не может без них обойтись, дальнейшие рассуждения о монадах продолжим на их примере.

## Класс типов Monad

Все монады представлены в лице класса типов `Monad`. Вот из чего он состоит:

```haskell
class Monad m where
    (>>=)  :: m a -> (a -> m b) -> m b
    (>>)   :: m a -> m b -> m b
    return :: a -> m a
    fail   :: String -> m a
```

Поскольку мы решили использовать в качестве примера монаду `IO`, для наглядности заменим полиморфный тип `m` реальным:

```haskell
class Monad IO where
    (>>=)  :: IO a -> (a -> IO b) -> IO b
    (>>)   :: IO a -> IO b -> IO b
    return :: a -> IO a
    fail   :: String -> IO a
```

Вспоминая пример с Unix-каналом, мы теперь понимаем, что `IO`-действие - это монадическая обёртка для результатов функций, взаимодействующих с внешним миром.

Исследуем эти четыре метода.

## Компоновка

Метод `(>>=)` - это оператор последовательной компоновки (sequentially composition). Иногда его ещё называют оператором связывания (bind). Именно этот оператор играет роль Unix-канала из нашей иллюстрации: он связывает два `IO`-действия воедино, извлекая результат, возвращённый левым действием, и передавая его в качестве аргумента правому действию.

Рассмотрим объявление этого метода:

```haskell
(>>=)  :: IO a -> (a -> IO b) -> IO b
```

Первый аргумент - это `IO`-действие, которое, выполнив свою работу, вернёт значение некоторого типа `a`. Второй аргумент - это функция, принимающая значение типа `a` в качестве аргумента и возвращающая `IO`-действие, которое, выполнив свою работу, вернёт значение некоторого типа `b`. А чтобы стало понятнее, позвольте мне прямо сейчас разоблачить do-нотацию.

Ключевое слово do - это всего лишь синтаксический сахар для монадических операторов. Возьмём простейших пример двух последовательных действий:

```haskell
main :: IO ()
main = do
    text <- getLine
    putStrLn $ "You said '" ++ text ++ "'"
```

А вот как этот код выглядит "по-настоящему", без do-нотации:

```haskell
main :: IO ()
main = getLine >>= \text -> putStrLn $ "You said '" ++ text ++ "'"
```

Теперь всё встало на свои места:

```haskell
getLine    >>=  \text   -> putStrLn $ "You said '" ++ text ++ "'"
IO String  >>=  (String -> IO ())
```

Когда "запускается" функция `getLine`, возвращающая `IO`-монаду, содержащую полученную от пользователя строку, оператор `>>=` вытаскивает эту строку из монады и сразу же передаёт её в качестве аргумента λ-функции, "запускающей" функцию `putStrLn`, которая в свою очередь вернёт другую `IO`-монаду.

Это именно то, что мы наблюдали в нашем примере с Unix-каналом:

```bash
$ ls | grep xml
```

Функция `getLine` заняла место утилиты `ls`, а λ-функция заняла место утилиты `grep`.

## Затем

Монадический оператор `>>` - это оператор "затем" (then). Это простейший случай связывания: действия связываются без извлечения значений. Вот такое связывание с do-нотацией:

```haskell
main :: IO ()
main = do
    putStrLn "Denis"
    putStrLn "Shevchenko"
```

А вот - без неё:

```haskell
main :: IO ()
main = putStrLn "Denis" >> putStrLn "Shevchenko"
```

Именно поэтому этот оператор и называется "затем". Мы говорим: "Сначала выведи на экран имя, а затем - фамилию". Никакой передачи значения здесь не происходит, ведь стоящая слева от оператора функция `putStrLn` возвращает пустое действие `IO ()`.

Если вспомнить аналогию с Unix-терминалом, это можно изобразить так:

```bash
$ whoami ; pwd
```

Оператор связки команд (command concatenator), представленный точкой с запятой - это и есть подобие оператора "затем". Сначала запускается `whoami`, а затем запускается `pwd`, никакой передачи значения слева направо тут нет.

## return

Метод `return` вам уже знаком. Теперь мы понимаем, что английское слово "return" хорошо отражает действие этой функции: она возвращает значение в монадическую обёртку. Вспомните наш пример:

```haskell
obtainTextFromUser :: IO String
obtainTextFromUser = do
    putStrLn "Enter your text, please: "
    firstText <- getLine
    return $ "'" ++ firstText ++ "'"
```

Функция `getLine` вернёт нам монаду, из которой оператор компоновки вытащит введённую пользователем строку. Эта строка поступит на вход λ-функции, которая в свою очередь создаст новую строку на основе строки, введённой пользователем, после чего - внимание! - функция `return` вернёт эту новоиспечённую строку обратно в `IO`-монаду. Вытащили значение из монады, что-то с ним сделали, а потом вернули в монаду.

Вы спросите, в чём же разница между `return` и упомянутой в главе об исключениях функцией `evaluate`? Разница в том, что функция `evaluate` заворачивает значение исключительно в монаду `IO`, в то время как функция `return` - в любую монаду, в зависимости от контекста. Рассматривайте `evaluate` как частный случай `return` для `IO`.

## fail

О методе `fail` мы говорить не будем. Во-первых, этот метод не имеет отношения к концептуальной сути монад. А во-вторых, поговаривают, будто в грядущем стандарте Haskell 2014 этот метод будет вообще убран из класса `Monad`.

Вот и всё. Теперь вы знаете простую суть монад. В принципе, монадический механизм - это всего лишь паттерн проектирования, унифицирующий процесс связывания вычислений.


